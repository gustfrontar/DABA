MODULE common_tools
!=======================================================================
!
! [PURPOSE:] General constants and procedures
!
! [ATTENTION:] This module calls 'SFMT.f90'
!
! [PUBLIC:]
!    checknan: Check for nan in a field
!    com_mdlerror: Generate a random vector with a given cov (input root of cov)    
!    forcing: Calculate forcing from polynomial parameterization. (common to all models)
! [HISTORY:]
!   07/20/2004 Takemasa MIYOSHI  created
!   01/23/2009 Takemasa MIYOSHI  modified for SFMT
!   01/04/2012 MAP  added checknan subroutines
!
!=======================================================================
  IMPLICIT NONE
  PUBLIC

!  public :: checknan
!  private :: checknan2, checknan1,checknan0
!  interface checknan
!     module procedure checknan2,checknan1, checknan0
!  end interface


!-----------------------------------------------------------------------
! Variable size definitions
!-----------------------------------------------------------------------
  INTEGER,PARAMETER :: r_size=kind(0.0d0)
  INTEGER,PARAMETER :: r_dble=kind(0.0d0)
  INTEGER,PARAMETER :: r_sngl=kind(0.0e0)
!-----------------------------------------------------------------------
! Constants
!-----------------------------------------------------------------------
  REAL(r_size),PARAMETER :: pi=3.1415926535
  REAL(r_size),PARAMETER :: gg=9.81
  REAL(r_size),PARAMETER :: rd=287.0
  REAL(r_size),PARAMETER :: cp=1005.7
  REAL(r_size),PARAMETER :: re=6371300.0
  REAL(r_size),PARAMETER :: r_omega=0.00007292
  REAL(r_size),PARAMETER :: t0c=273.15
  REAL(r_size),PARAMETER :: undef=-99999999999.99

CONTAINS

!=======================================================================

SUBROUTINE com_mean(ndim,var,amean)
!
! Mean
!
  IMPLICIT NONE

  INTEGER,INTENT(IN) :: ndim
  REAL(r_size),INTENT(IN) :: var(ndim)
  REAL(r_size),INTENT(OUT) :: amean

  INTEGER :: i

  amean = 0.0
!  DO i=1,ndim
!    amean = amean + var(i)
!  END DO
  amean = sum( var )
  amean = amean / REAL(ndim,r_size)

  RETURN
END SUBROUTINE com_mean

!=======================================================================

SUBROUTINE com_stdev(ndim,var,aout)
!
! Standard deviation
!
  IMPLICIT NONE

  INTEGER,INTENT(IN) :: ndim
  REAL(r_size),INTENT(IN) :: var(ndim)
  REAL(r_size),INTENT(OUT) :: aout

  REAL(r_size) :: amean
  REAL(r_size) :: dev(ndim)

  CALL com_mean(ndim,var,amean)

  dev(:) = var(:) - amean

  aout = SQRT( SUM(dev*dev) / REAL(ndim-1,r_size) )

  RETURN
END SUBROUTINE com_stdev

!=======================================================================


SUBROUTINE com_var(ndim,var,aout)
!
! Sample variance
!
  IMPLICIT NONE

  INTEGER,INTENT(IN) :: ndim
  REAL(r_size),INTENT(IN) :: var(ndim)
  REAL(r_size),INTENT(OUT) :: aout

  REAL(r_size) :: amean
  REAL(r_size) :: dev(ndim)

  CALL com_mean(ndim,var,amean)

  dev(:) = var(:) - amean

  aout = SUM(dev*dev) / REAL(ndim-1,r_size) 

  RETURN
END SUBROUTINE com_var

!=======================================================================


SUBROUTINE com_covar(ndim,var1,var2,cov)
!
! Covariance
!
  IMPLICIT NONE

  INTEGER,INTENT(IN) :: ndim
  REAL(r_size),INTENT(IN) :: var1(ndim)
  REAL(r_size),INTENT(IN) :: var2(ndim)
  REAL(r_size),INTENT(OUT) :: cov

  REAL(r_size) :: amean1,amean2
  REAL(r_size) :: dev1(ndim),dev2(ndim)

  CALL com_mean(ndim,var1,amean1)
  CALL com_mean(ndim,var2,amean2)

  dev1(:) = var1(:) - amean1
  dev2(:) = var2(:) - amean2

  cov = SUM( dev1*dev2 ) / REAL(ndim-1,r_size)

  RETURN
END SUBROUTINE com_covar

!=======================================================================

SUBROUTINE com_correl(ndim,var1,var2,cor)
!
! Correlation
!
  IMPLICIT NONE

  INTEGER,INTENT(IN) :: ndim
  REAL(r_size),INTENT(IN) :: var1(ndim)
  REAL(r_size),INTENT(IN) :: var2(ndim)
  REAL(r_size),INTENT(OUT) :: cor

  REAL(r_size) :: cov,stdev1,stdev2

  CALL com_stdev(ndim,var1,stdev1)
  CALL com_stdev(ndim,var2,stdev2)
  CALL com_covar(ndim,var1,var2,cov)

  cor = cov/stdev1/stdev2

  RETURN
END SUBROUTINE com_correl

!=======================================================================!

SUBROUTINE com_anomcorrel(ndim,var1,var2,varmean,cor)
!
! Anomaly Correlation
!
  IMPLICIT NONE

  INTEGER,INTENT(IN) :: ndim
  REAL(r_size),INTENT(IN) :: var1(ndim)
  REAL(r_size),INTENT(IN) :: var2(ndim)
  REAL(r_size),INTENT(IN) :: varmean(ndim)
  REAL(r_size),INTENT(OUT) :: cor

  REAL(r_size) :: dev1(ndim),dev2(ndim)

  dev1 = var1 - varmean
  dev2 = var2 - varmean

  cor = SUM( dev1*dev2 ) / SQRT( SUM(dev1*dev1) * SUM(dev2*dev2) )

  RETURN
END SUBROUTINE com_anomcorrel

!=======================================================================!

SUBROUTINE com_l2norm(ndim,var,anorm)
!
! L2 Norm
!
  IMPLICIT NONE

  INTEGER,INTENT(IN) :: ndim
  REAL(r_size),INTENT(IN) :: var(ndim)
  REAL(r_size),INTENT(OUT) :: anorm

  anorm = SQRT( SUM(var*var) )

  RETURN
END SUBROUTINE com_l2norm

!=======================================================================

SUBROUTINE com_rms(ndim,var,rmsv)
!
! RMS (root mean square)
!
  IMPLICIT NONE

  INTEGER,INTENT(IN) :: ndim
  REAL(r_size),INTENT(IN) :: var(ndim)
  REAL(r_size),INTENT(OUT) :: rmsv

  rmsv = SQRT( SUM(var*var) / REAL(ndim,r_size) )

  RETURN
END SUBROUTINE com_rms

!=======================================================================

SUBROUTINE com_filter_lanczos(ndim,fc,var)
!
! Lanczos Filter (Low-pass) with cyclic boundary
!
  IMPLICIT NONE

  INTEGER,INTENT(IN) :: ndim
  REAL(r_size),INTENT(IN) :: fc    ! critical frequency in [0,pi]
  REAL(r_size),INTENT(INOUT) :: var(ndim)

  INTEGER,PARAMETER :: lresol=10

  REAL(r_size) :: weight(-lresol:lresol)
  REAL(r_size) :: varwk(1-lresol:ndim+lresol)
  REAL(r_size) :: rl,rlresol
  INTEGER :: i,l
!
! Weight
!
  rlresol = REAL(lresol,r_size)
  DO l=-lresol,-1
    rl = REAL(l,r_size)
    weight(l) = SIN(fc*rl) * SIN(pi*rl/rlresol) &
      & * rlresol / pi / rl / pi / rl
  END DO
  DO l=1,lresol
    rl = REAL(l,r_size)
    weight(l) = SIN(fc*rl) * SIN(pi*rl/rlresol) &
      & * rlresol / pi / rl / pi / rl
  END DO
  weight(0) = fc / pi
!
! Cyclic boundary
!
  DO i=0,1-lresol,-1
    varwk(i) = var(ndim+i)
  END DO
  DO i=ndim+1,ndim+lresol
    varwk(i) = var(i-ndim)
  END DO
  varwk(1:ndim) = var(1:ndim)
!
! Filter
!
  var = 0.0
  DO i=1,ndim
    DO l=-lresol,lresol
      var(i) = var(i) + weight(l) * varwk(i+l)
    END DO
  END DO

  RETURN
END SUBROUTINE com_filter_lanczos

!=======================================================================

SUBROUTINE com_rand(ndim,var)
!
! RAND (random number with uniform distribution)
! This function has been modified to use RANDOM_NUMBER which is
! thread safe when using OpenMP
! https://gcc.gnu.org/onlinedocs/gfortran/RANDOM_005fNUMBER.html#RANDOM_005fNUMBER
!

  IMPLICIT NONE

  INTEGER,INTENT(IN) :: ndim
  REAL(r_size),INTENT(OUT) :: var(1:ndim)
  INTEGER :: i 

  DO i=1,ndim
    CALL RANDOM_NUMBER(var(i))
  END DO

  RETURN
END SUBROUTINE com_rand

!=======================================================================

SUBROUTINE com_randn(ndim,var)
!
! RANDN (random number with normal distribution)
! This function has been modified to use RANDOM_NUMBER which is 
! thread safe when using OpenMP
! https://gcc.gnu.org/onlinedocs/gfortran/RANDOM_005fNUMBER.html#RANDOM_005fNUMBER
!

  IMPLICIT NONE

  INTEGER,INTENT(IN) :: ndim
  REAL(r_size),INTENT(OUT) :: var(1:ndim)
  REAL(r_size) :: rnd(2)
  INTEGER :: idate(8)
  INTEGER :: i

  IF( MOD(ndim,2)==0 ) THEN
    DO i=1,ndim/2
      CALL RANDOM_NUMBER(rnd(1)) 
      CALL RANDOM_NUMBER(rnd(2)) 
      var(i*2-1) = sqrt( -2.0 * log( rnd(1) ) ) * sin( 2.0*pi*rnd(2) )
      var(i*2) = sqrt( -2.0 * log( rnd(1) ) ) * cos( 2.0*pi*rnd(2) )
    END DO
  ELSE
    DO i=1,(ndim-1)/2
      CALL RANDOM_NUMBER(rnd(1)) 
      CALL RANDOM_NUMBER(rnd(2)) 
      var(i*2-1) = sqrt( -2.0 * log( rnd(1) ) ) * sin( 2.0*pi*rnd(2) )
      var(i*2) = sqrt( -2.0 * log( rnd(1) ) ) * cos( 2.0*pi*rnd(2) )
    END DO
    CALL RANDOM_NUMBER(rnd(1)) 
    CALL RANDOM_NUMBER(rnd(2)) 
    var(ndim) = sqrt( -2.0 * log( rnd(1) ) ) * sin( 2.0*pi*rnd(2) )
  END IF

  RETURN
END SUBROUTINE com_randn



SUBROUTINE com_interp_spline(ndim,x,y,n,x5,y5)
!
! Cubic spline interpolation
!   [Reference:] Akima, H., 1970: J. ACM, 17, 589-602.
!
  IMPLICIT NONE
  INTEGER,INTENT(IN) :: ndim         ! number of grid points
  REAL(r_size),INTENT(IN) :: x(ndim) ! coordinate
  REAL(r_size),INTENT(IN) :: y(ndim) ! variable
  INTEGER,INTENT(IN) :: n            ! number of targets
  REAL(r_size),INTENT(IN) :: x5(n)   ! target coordinates
  REAL(r_size),INTENT(OUT) :: y5(n)  ! target values
  INTEGER :: i,j,m
  REAL(r_size) :: dydx(5),ddydx(4),t(2),dx21,dx
  REAL(r_size) :: wk

  TGT: DO j=1,n
    DO i=1,ndim
      IF(x5(j) == x(i)) THEN
        y5(j) = y(i)
        CYCLE TGT
      END IF
      IF(x5(j) < x(i)) EXIT
    END DO
!       i-3   i-2   i-1    i    i+1   i+2
!     ---+-----+-----+---*-+-----+-----+---
!dydx       1     2     3     4     5
!ddydx         1     2     3     4
!t                   1     2
    IF(i==2) THEN
      DO m=3,5
        dydx(m) = (y(i-3+m)-y(i-4+m)) / (x(i-3+m)-x(i-4+m))
      END DO
      dydx(2) = 2.0d0*dydx(3) - dydx(4)
      dydx(1) = 2.0d0*dydx(2) - dydx(3)
    ELSE IF(i==3) THEN
      DO m=2,5
        dydx(m) = (y(i-3+m)-y(i-4+m)) / (x(i-3+m)-x(i-4+m))
      END DO
      dydx(1) = 2.0d0*dydx(2) - dydx(3)
    ELSE IF(i==ndim) THEN
      DO m=1,3
        dydx(m) = (y(i-3+m)-y(i-4+m)) / (x(i-3+m)-x(i-4+m))
      END DO
      dydx(4) = 2.0d0*dydx(3) - dydx(2)
      dydx(5) = 2.0d0*dydx(4) - dydx(3)
    ELSE IF(i==ndim-1) THEN
      DO m=1,4
        dydx(m) = (y(i-3+m)-y(i-4+m)) / (x(i-3+m)-x(i-4+m))
      END DO
      dydx(5) = 2.0d0*dydx(4) - dydx(3)
    ELSE
      DO m=1,5
        dydx(m) = (y(i-3+m)-y(i-4+m)) / (x(i-3+m)-x(i-4+m))
      END DO
    END IF
    DO m=1,4
      ddydx(m) = ABS(dydx(m+1) - dydx(m))
    END DO
    DO m=1,2
      wk = ddydx(m+2) + ddydx(m)
      IF(wk == 0) THEN
        t(m) = 0.0
      ELSE
        t(m) = (ddydx(m+2)*dydx(m+1)+ddydx(m)*dydx(m+2))/wk
      END IF
    END DO
    dx21 = x(i)-x(i-1)
    dx = x5(j) - x(i-1)
    y5(j) = y(i-1) &
        & + dx*t(1) &
        & + dx*dx*(3.0d0*dydx(3)-2.0d0*t(1)-t(2))/dx21 &
        & + dx*dx*dx*(t(1)+t(2)-2.0d0*dydx(3))/dx21/dx21
  END DO TGT

  RETURN
END SUBROUTINE com_interp_spline

SUBROUTINE log_sum_vec( ne , logvec , log_sum )
!Compute log( sum( vec ) ) based on knowing the logs of each element of vec.
IMPLICIT NONE
INTEGER, INTENT(IN)       :: ne
REAL(r_size) , INTENT(IN) :: logvec(ne)
REAL(r_size) , INTENT(OUT):: log_sum
REAL(r_size)              :: max_log_vec

max_log_vec = MAXVAL( logvec )

log_sum = max_log_vec + LOG( SUM( EXP( logvec - max_log_vec ) ) )

END SUBROUTINE log_sum_vec



END MODULE common_tools
